// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1-0.20250807144615-80635cd45a20 DO NOT EDIT.
package api

import (
	"fmt"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for MemberStatus.
const (
	MemberStatusActive    MemberStatus = "active"
	MemberStatusCanceled  MemberStatus = "canceled"
	MemberStatusSuspended MemberStatus = "suspended"
)

// Defines values for ResourceStatus.
const (
	ResourceStatusActive      ResourceStatus = "active"
	ResourceStatusMaintenance ResourceStatus = "maintenance"
	ResourceStatusRetired     ResourceStatus = "retired"
)

// Defines values for Role.
const (
	MEMBER Role = "MEMBER"
	OWNER  Role = "OWNER"
	STAFF  Role = "STAFF"
)

// Defines values for UtilizationSessionSource.
const (
	UtilizationSessionSourceApi   UtilizationSessionSource = "api"
	UtilizationSessionSourceSelf  UtilizationSessionSource = "self"
	UtilizationSessionSourceStaff UtilizationSessionSource = "staff"
)

// Defines values for UtilizationSessionStatus.
const (
	UtilizationSessionStatusActive   UtilizationSessionStatus = "active"
	UtilizationSessionStatusCanceled UtilizationSessionStatus = "canceled"
	UtilizationSessionStatusEnded    UtilizationSessionStatus = "ended"
)

// Defines values for PostMembersJSONBodyStatus.
const (
	PostMembersJSONBodyStatusActive    PostMembersJSONBodyStatus = "active"
	PostMembersJSONBodyStatusCanceled  PostMembersJSONBodyStatus = "canceled"
	PostMembersJSONBodyStatusSuspended PostMembersJSONBodyStatus = "suspended"
)

// Defines values for PostResourcesJSONBodyStatus.
const (
	PostResourcesJSONBodyStatusActive      PostResourcesJSONBodyStatus = "active"
	PostResourcesJSONBodyStatusMaintenance PostResourcesJSONBodyStatus = "maintenance"
	PostResourcesJSONBodyStatusRetired     PostResourcesJSONBodyStatus = "retired"
)

// Defines values for PatchResourcesResourceIdJSONBodyStatus.
const (
	PatchResourcesResourceIdJSONBodyStatusActive      PatchResourcesResourceIdJSONBodyStatus = "active"
	PatchResourcesResourceIdJSONBodyStatusMaintenance PatchResourcesResourceIdJSONBodyStatus = "maintenance"
	PatchResourcesResourceIdJSONBodyStatusRetired     PatchResourcesResourceIdJSONBodyStatus = "retired"
)

// Defines values for PostSessionsJSONBodySource.
const (
	PostSessionsJSONBodySourceApi   PostSessionsJSONBodySource = "api"
	PostSessionsJSONBodySourceSelf  PostSessionsJSONBodySource = "self"
	PostSessionsJSONBodySourceStaff PostSessionsJSONBodySource = "staff"
)

// AuditLog defines model for AuditLog.
type AuditLog struct {
	Action      string                  `json:"action"`
	ActorUserId string                  `json:"actor_user_id"`
	CreatedAt   time.Time               `json:"created_at"`
	DiffJson    *map[string]interface{} `json:"diff_json,omitempty"`
	Entity      string                  `json:"entity"`
	EntityId    string                  `json:"entity_id"`
	GymId       string                  `json:"gym_id"`
	Id          string                  `json:"id"`
}

// AuthLoginRequest defines model for AuthLoginRequest.
type AuthLoginRequest struct {
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
}

// AuthLoginResponse defines model for AuthLoginResponse.
type AuthLoginResponse struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
	User         User   `json:"user"`
}

// DashboardNow defines model for DashboardNow.
type DashboardNow struct {
	Groups *[]struct {
		ActiveSessions       *int    `json:"active_sessions,omitempty"`
		Capacity             *int    `json:"capacity,omitempty"`
		EstimatedWaitMinutes *int    `json:"estimated_wait_minutes"`
		GroupId              *string `json:"group_id,omitempty"`
		Name                 *string `json:"name,omitempty"`
	} `json:"groups,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Code Machine-readable error code
	Code    *string                 `json:"code,omitempty"`
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   string                  `json:"error"`
}

// Gym defines model for Gym.
type Gym struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        string     `json:"id"`
	Name      string     `json:"name"`
	Timezone  string     `json:"timezone"`
}

// Member defines model for Member.
type Member struct {
	CreatedAt        *time.Time    `json:"created_at,omitempty"`
	ExternalMemberId *string       `json:"external_member_id"`
	GymId            string        `json:"gym_id"`
	Id               string        `json:"id"`
	Name             string        `json:"name"`
	Status           *MemberStatus `json:"status,omitempty"`
}

// MemberStatus defines model for Member.Status.
type MemberStatus string

// Page defines model for Page.
type Page struct {
	NextCursor *string `json:"next_cursor"`
}

// RefreshRequest defines model for RefreshRequest.
type RefreshRequest struct {
	RefreshToken string `json:"refresh_token"`
}

// Resource defines model for Resource.
type Resource struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// ExternalId QR/NFC code
	ExternalId *string         `json:"external_id"`
	GroupId    string          `json:"group_id"`
	GymId      string          `json:"gym_id"`
	Id         string          `json:"id"`
	Label      string          `json:"label"`
	Status     *ResourceStatus `json:"status,omitempty"`
}

// ResourceStatus defines model for Resource.Status.
type ResourceStatus string

// ResourceGroup defines model for ResourceGroup.
type ResourceGroup struct {
	Capacity  int        `json:"capacity"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	GymId     string     `json:"gym_id"`
	Id        string     `json:"id"`
	Name      string     `json:"name"`

	// RulesJson Arbitrary rules e.g. { max_minutes: 30 }
	RulesJson *map[string]interface{} `json:"rules_json,omitempty"`
	ZoneId    *string                 `json:"zone_id"`
}

// Role defines model for Role.
type Role string

// User defines model for User.
type User struct {
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Email     openapi_types.Email `json:"email"`
	GymId     string              `json:"gym_id"`
	Id        string              `json:"id"`
	IsActive  bool                `json:"is_active"`
	Role      Role                `json:"role"`
}

// UtilizationSession defines model for UtilizationSession.
type UtilizationSession struct {
	AnomaliesJson *map[string]interface{}   `json:"anomalies_json,omitempty"`
	CreatedAt     *time.Time                `json:"created_at,omitempty"`
	DurationSec   *int                      `json:"duration_sec"`
	EndedAt       *time.Time                `json:"ended_at"`
	GroupId       string                    `json:"group_id"`
	GymId         string                    `json:"gym_id"`
	Id            string                    `json:"id"`
	MemberId      *string                   `json:"member_id"`
	ResourceId    *string                   `json:"resource_id"`
	Source        *UtilizationSessionSource `json:"source,omitempty"`
	StartedAt     time.Time                 `json:"started_at"`
	Status        UtilizationSessionStatus  `json:"status"`
}

// UtilizationSessionSource defines model for UtilizationSession.Source.
type UtilizationSessionSource string

// UtilizationSessionStatus defines model for UtilizationSession.Status.
type UtilizationSessionStatus string

// Zone defines model for Zone.
type Zone struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	GymId     string     `json:"gym_id"`
	Id        string     `json:"id"`
	Name      string     `json:"name"`
}

// GymId defines model for GymId.
type GymId = string

// PaginationCursor Opaque cursor for forward pagination
type PaginationCursor = string

// PaginationLimit defines model for PaginationLimit.
type PaginationLimit = int

// TimeFrom defines model for TimeFrom.
type TimeFrom = time.Time

// TimeTo defines model for TimeTo.
type TimeTo = time.Time

// GetAuditLogsParams defines parameters for GetAuditLogs.
type GetAuditLogsParams struct {
	Entity   *string           `form:"entity,omitempty" json:"entity,omitempty"`
	EntityId *string           `form:"entity_id,omitempty" json:"entity_id,omitempty"`
	Limit    *PaginationLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Cursor   *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// GetDashboardNowParams defines parameters for GetDashboardNow.
type GetDashboardNowParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// GetGymsMeParams defines parameters for GetGymsMe.
type GetGymsMeParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// GetMembersParams defines parameters for GetMembers.
type GetMembersParams struct {
	Limit  *PaginationLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PostMembersJSONBody defines parameters for PostMembers.
type PostMembersJSONBody struct {
	ExternalMemberId *string                    `json:"external_member_id"`
	Name             string                     `json:"name"`
	Status           *PostMembersJSONBodyStatus `json:"status,omitempty"`
}

// PostMembersParams defines parameters for PostMembers.
type PostMembersParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PostMembersJSONBodyStatus defines parameters for PostMembers.
type PostMembersJSONBodyStatus string

// GetResourceGroupsParams defines parameters for GetResourceGroups.
type GetResourceGroupsParams struct {
	Limit  *PaginationLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PostResourceGroupsJSONBody defines parameters for PostResourceGroups.
type PostResourceGroupsJSONBody struct {
	Capacity  int                     `json:"capacity"`
	Name      string                  `json:"name"`
	RulesJson *map[string]interface{} `json:"rules_json,omitempty"`
	ZoneId    *string                 `json:"zone_id"`
}

// PostResourceGroupsParams defines parameters for PostResourceGroups.
type PostResourceGroupsParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PatchResourceGroupsGroupIdJSONBody defines parameters for PatchResourceGroupsGroupId.
type PatchResourceGroupsGroupIdJSONBody struct {
	Capacity  *int                    `json:"capacity,omitempty"`
	Name      *string                 `json:"name,omitempty"`
	RulesJson *map[string]interface{} `json:"rules_json,omitempty"`
	ZoneId    *string                 `json:"zone_id"`
}

// PatchResourceGroupsGroupIdParams defines parameters for PatchResourceGroupsGroupId.
type PatchResourceGroupsGroupIdParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// GetResourcesParams defines parameters for GetResources.
type GetResourcesParams struct {
	Limit  *PaginationLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PostResourcesJSONBody defines parameters for PostResources.
type PostResourcesJSONBody struct {
	ExternalId *string                      `json:"external_id"`
	GroupId    string                       `json:"group_id"`
	Label      string                       `json:"label"`
	Status     *PostResourcesJSONBodyStatus `json:"status,omitempty"`
}

// PostResourcesParams defines parameters for PostResources.
type PostResourcesParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PostResourcesJSONBodyStatus defines parameters for PostResources.
type PostResourcesJSONBodyStatus string

// PatchResourcesResourceIdJSONBody defines parameters for PatchResourcesResourceId.
type PatchResourcesResourceIdJSONBody struct {
	ExternalId *string                                 `json:"external_id"`
	GroupId    *string                                 `json:"group_id,omitempty"`
	Label      *string                                 `json:"label,omitempty"`
	Status     *PatchResourcesResourceIdJSONBodyStatus `json:"status,omitempty"`
}

// PatchResourcesResourceIdParams defines parameters for PatchResourcesResourceId.
type PatchResourcesResourceIdParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PatchResourcesResourceIdJSONBodyStatus defines parameters for PatchResourcesResourceId.
type PatchResourcesResourceIdJSONBodyStatus string

// GetSessionsParams defines parameters for GetSessions.
type GetSessionsParams struct {
	From     *TimeFrom         `form:"from,omitempty" json:"from,omitempty"`
	To       *TimeTo           `form:"to,omitempty" json:"to,omitempty"`
	GroupId  *string           `form:"group_id,omitempty" json:"group_id,omitempty"`
	MemberId *string           `form:"member_id,omitempty" json:"member_id,omitempty"`
	Limit    *PaginationLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Cursor   *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PostSessionsJSONBody defines parameters for PostSessions.
type PostSessionsJSONBody struct {
	GroupId    string                      `json:"group_id"`
	MemberId   *string                     `json:"member_id"`
	ResourceId *string                     `json:"resource_id"`
	Source     *PostSessionsJSONBodySource `json:"source,omitempty"`
}

// PostSessionsParams defines parameters for PostSessions.
type PostSessionsParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PostSessionsJSONBodySource defines parameters for PostSessions.
type PostSessionsJSONBodySource string

// PatchSessionsSessionIdEndJSONBody defines parameters for PatchSessionsSessionIdEnd.
type PatchSessionsSessionIdEndJSONBody struct {
	// EndedAt Optional override (defaults to now)
	EndedAt *time.Time `json:"ended_at,omitempty"`
}

// PatchSessionsSessionIdEndParams defines parameters for PatchSessionsSessionIdEnd.
type PatchSessionsSessionIdEndParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// GetZonesParams defines parameters for GetZones.
type GetZonesParams struct {
	Limit  *PaginationLimit  `form:"limit,omitempty" json:"limit,omitempty"`
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PostZonesJSONBody defines parameters for PostZones.
type PostZonesJSONBody struct {
	Name string `json:"name"`
}

// PostZonesParams defines parameters for PostZones.
type PostZonesParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PatchZonesZoneIdJSONBody defines parameters for PatchZonesZoneId.
type PatchZonesZoneIdJSONBody struct {
	Name *string `json:"name,omitempty"`
}

// PatchZonesZoneIdParams defines parameters for PatchZonesZoneId.
type PatchZonesZoneIdParams struct {
	// XGymID Current gym/tenant context. Owner accounts can switch gyms.
	XGymID GymId `json:"X-Gym-ID"`
}

// PostAuthLoginJSONRequestBody defines body for PostAuthLogin for application/json ContentType.
type PostAuthLoginJSONRequestBody = AuthLoginRequest

// PostAuthRefreshJSONRequestBody defines body for PostAuthRefresh for application/json ContentType.
type PostAuthRefreshJSONRequestBody = RefreshRequest

// PostMembersJSONRequestBody defines body for PostMembers for application/json ContentType.
type PostMembersJSONRequestBody PostMembersJSONBody

// PostResourceGroupsJSONRequestBody defines body for PostResourceGroups for application/json ContentType.
type PostResourceGroupsJSONRequestBody PostResourceGroupsJSONBody

// PatchResourceGroupsGroupIdJSONRequestBody defines body for PatchResourceGroupsGroupId for application/json ContentType.
type PatchResourceGroupsGroupIdJSONRequestBody PatchResourceGroupsGroupIdJSONBody

// PostResourcesJSONRequestBody defines body for PostResources for application/json ContentType.
type PostResourcesJSONRequestBody PostResourcesJSONBody

// PatchResourcesResourceIdJSONRequestBody defines body for PatchResourcesResourceId for application/json ContentType.
type PatchResourcesResourceIdJSONRequestBody PatchResourcesResourceIdJSONBody

// PostSessionsJSONRequestBody defines body for PostSessions for application/json ContentType.
type PostSessionsJSONRequestBody PostSessionsJSONBody

// PatchSessionsSessionIdEndJSONRequestBody defines body for PatchSessionsSessionIdEnd for application/json ContentType.
type PatchSessionsSessionIdEndJSONRequestBody PatchSessionsSessionIdEndJSONBody

// PostZonesJSONRequestBody defines body for PostZones for application/json ContentType.
type PostZonesJSONRequestBody PostZonesJSONBody

// PatchZonesZoneIdJSONRequestBody defines body for PatchZonesZoneId for application/json ContentType.
type PatchZonesZoneIdJSONRequestBody PatchZonesZoneIdJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List audit logs
	// (GET /audit-logs)
	GetAuditLogs(c *gin.Context, params GetAuditLogsParams)
	// Login and obtain JWTs
	// (POST /auth/login)
	PostAuthLogin(c *gin.Context)
	// Refresh access token
	// (POST /auth/refresh)
	PostAuthRefresh(c *gin.Context)
	// Current utilization per group
	// (GET /dashboard/now)
	GetDashboardNow(c *gin.Context, params GetDashboardNowParams)
	// Get current gym context
	// (GET /gyms/me)
	GetGymsMe(c *gin.Context, params GetGymsMeParams)
	// List members
	// (GET /members)
	GetMembers(c *gin.Context, params GetMembersParams)
	// Create member
	// (POST /members)
	PostMembers(c *gin.Context, params PostMembersParams)
	// List resource groups
	// (GET /resource-groups)
	GetResourceGroups(c *gin.Context, params GetResourceGroupsParams)
	// Create a resource group
	// (POST /resource-groups)
	PostResourceGroups(c *gin.Context, params PostResourceGroupsParams)
	// Update a resource group
	// (PATCH /resource-groups/{group_id})
	PatchResourceGroupsGroupId(c *gin.Context, groupId string, params PatchResourceGroupsGroupIdParams)
	// List resources (optional per-unit tracking)
	// (GET /resources)
	GetResources(c *gin.Context, params GetResourcesParams)
	// Create resource
	// (POST /resources)
	PostResources(c *gin.Context, params PostResourcesParams)
	// Update resource
	// (PATCH /resources/{resource_id})
	PatchResourcesResourceId(c *gin.Context, resourceId string, params PatchResourcesResourceIdParams)
	// List sessions (historical)
	// (GET /sessions)
	GetSessions(c *gin.Context, params GetSessionsParams)
	// Start a session (check-in)
	// (POST /sessions)
	PostSessions(c *gin.Context, params PostSessionsParams)
	// End a session (check-out now)
	// (PATCH /sessions/{session_id}/end)
	PatchSessionsSessionIdEnd(c *gin.Context, sessionId string, params PatchSessionsSessionIdEndParams)
	// List zones
	// (GET /zones)
	GetZones(c *gin.Context, params GetZonesParams)
	// Create zone
	// (POST /zones)
	PostZones(c *gin.Context, params PostZonesParams)
	// Update zone
	// (PATCH /zones/{zone_id})
	PatchZonesZoneId(c *gin.Context, zoneId string, params PatchZonesZoneIdParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetAuditLogs operation middleware
func (siw *ServerInterfaceWrapper) GetAuditLogs(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuditLogsParams

	// ------------- Optional query parameter "entity" -------------

	err = runtime.BindQueryParameter("form", true, false, "entity", c.Request.URL.Query(), &params.Entity)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter entity: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "entity_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "entity_id", c.Request.URL.Query(), &params.EntityId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter entity_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAuditLogs(c, params)
}

// PostAuthLogin operation middleware
func (siw *ServerInterfaceWrapper) PostAuthLogin(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostAuthLogin(c)
}

// PostAuthRefresh operation middleware
func (siw *ServerInterfaceWrapper) PostAuthRefresh(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostAuthRefresh(c)
}

// GetDashboardNow operation middleware
func (siw *ServerInterfaceWrapper) GetDashboardNow(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDashboardNowParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetDashboardNow(c, params)
}

// GetGymsMe operation middleware
func (siw *ServerInterfaceWrapper) GetGymsMe(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGymsMeParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetGymsMe(c, params)
}

// GetMembers operation middleware
func (siw *ServerInterfaceWrapper) GetMembers(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMembersParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMembers(c, params)
}

// PostMembers operation middleware
func (siw *ServerInterfaceWrapper) PostMembers(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostMembersParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostMembers(c, params)
}

// GetResourceGroups operation middleware
func (siw *ServerInterfaceWrapper) GetResourceGroups(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetResourceGroupsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetResourceGroups(c, params)
}

// PostResourceGroups operation middleware
func (siw *ServerInterfaceWrapper) PostResourceGroups(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostResourceGroupsParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostResourceGroups(c, params)
}

// PatchResourceGroupsGroupId operation middleware
func (siw *ServerInterfaceWrapper) PatchResourceGroupsGroupId(c *gin.Context) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupId string

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", c.Param("group_id"), &groupId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter group_id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchResourceGroupsGroupIdParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchResourceGroupsGroupId(c, groupId, params)
}

// GetResources operation middleware
func (siw *ServerInterfaceWrapper) GetResources(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetResourcesParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetResources(c, params)
}

// PostResources operation middleware
func (siw *ServerInterfaceWrapper) PostResources(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostResourcesParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostResources(c, params)
}

// PatchResourcesResourceId operation middleware
func (siw *ServerInterfaceWrapper) PatchResourcesResourceId(c *gin.Context) {

	var err error

	// ------------- Path parameter "resource_id" -------------
	var resourceId string

	err = runtime.BindStyledParameterWithOptions("simple", "resource_id", c.Param("resource_id"), &resourceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter resource_id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchResourcesResourceIdParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchResourcesResourceId(c, resourceId, params)
}

// GetSessions operation middleware
func (siw *ServerInterfaceWrapper) GetSessions(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSessionsParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", c.Request.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter from: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", c.Request.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter to: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "group_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group_id", c.Request.URL.Query(), &params.GroupId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter group_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "member_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "member_id", c.Request.URL.Query(), &params.MemberId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter member_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSessions(c, params)
}

// PostSessions operation middleware
func (siw *ServerInterfaceWrapper) PostSessions(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostSessionsParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSessions(c, params)
}

// PatchSessionsSessionIdEnd operation middleware
func (siw *ServerInterfaceWrapper) PatchSessionsSessionIdEnd(c *gin.Context) {

	var err error

	// ------------- Path parameter "session_id" -------------
	var sessionId string

	err = runtime.BindStyledParameterWithOptions("simple", "session_id", c.Param("session_id"), &sessionId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter session_id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchSessionsSessionIdEndParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchSessionsSessionIdEnd(c, sessionId, params)
}

// GetZones operation middleware
func (siw *ServerInterfaceWrapper) GetZones(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetZonesParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetZones(c, params)
}

// PostZones operation middleware
func (siw *ServerInterfaceWrapper) PostZones(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostZonesParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostZones(c, params)
}

// PatchZonesZoneId operation middleware
func (siw *ServerInterfaceWrapper) PatchZonesZoneId(c *gin.Context) {

	var err error

	// ------------- Path parameter "zone_id" -------------
	var zoneId string

	err = runtime.BindStyledParameterWithOptions("simple", "zone_id", c.Param("zone_id"), &zoneId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter zone_id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchZonesZoneIdParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Gym-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Gym-ID")]; found {
		var XGymID GymId
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Gym-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Gym-ID", valueList[0], &XGymID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Gym-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XGymID = XGymID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Gym-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchZonesZoneId(c, zoneId, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/audit-logs", wrapper.GetAuditLogs)
	router.POST(options.BaseURL+"/auth/login", wrapper.PostAuthLogin)
	router.POST(options.BaseURL+"/auth/refresh", wrapper.PostAuthRefresh)
	router.GET(options.BaseURL+"/dashboard/now", wrapper.GetDashboardNow)
	router.GET(options.BaseURL+"/gyms/me", wrapper.GetGymsMe)
	router.GET(options.BaseURL+"/members", wrapper.GetMembers)
	router.POST(options.BaseURL+"/members", wrapper.PostMembers)
	router.GET(options.BaseURL+"/resource-groups", wrapper.GetResourceGroups)
	router.POST(options.BaseURL+"/resource-groups", wrapper.PostResourceGroups)
	router.PATCH(options.BaseURL+"/resource-groups/:group_id", wrapper.PatchResourceGroupsGroupId)
	router.GET(options.BaseURL+"/resources", wrapper.GetResources)
	router.POST(options.BaseURL+"/resources", wrapper.PostResources)
	router.PATCH(options.BaseURL+"/resources/:resource_id", wrapper.PatchResourcesResourceId)
	router.GET(options.BaseURL+"/sessions", wrapper.GetSessions)
	router.POST(options.BaseURL+"/sessions", wrapper.PostSessions)
	router.PATCH(options.BaseURL+"/sessions/:session_id/end", wrapper.PatchSessionsSessionIdEnd)
	router.GET(options.BaseURL+"/zones", wrapper.GetZones)
	router.POST(options.BaseURL+"/zones", wrapper.PostZones)
	router.PATCH(options.BaseURL+"/zones/:zone_id", wrapper.PatchZonesZoneId)
}
